program = @{
  SOI
  ~ (block ~ (empty_line+ ~ block)*)?
  ~ empty_line*
  ~ EOI
}

block = @{
  empty_line*
  ~ assignment_or_expression ~ (next_assignment_or_expression)*
}
child_block = @{
  empty_line*
  ~ push_indentation
  ~ (map_value | block)
  ~ DROP
}

expression_block = @{
  empty_line*
  ~ push_indentation
  ~ expression
  ~ (WHITESPACE* ~ ",")?
  ~ next_expression*
  ~ DROP
}
next_expression = @{
  NEWLINE
  ~ empty_line*
  ~ indentation
  ~ expression
  ~ (WHITESPACE* ~ ",")?
}

push_indentation = @{ indentation ~ PUSH(indent) }
indentation = @{ PEEK_ALL }
indent = _{ WHITESPACE+ }

assignment_or_expression = _{ (assignment | expressions) ~ comment? }
next_assignment_or_expression = @{
  NEWLINE
  ~ empty_line*
  ~ indentation
  ~ assignment_or_expression
}

assignment = _{ single_assignment | multiple_assignment }
single_assignment = !{
  assignment_target
  ~ "=" ~ (expressions | expression_block)
}
multiple_assignment = !{
  assignment_targets
  ~ "=" ~ (expressions | expression_block) }
assignment_target = _{ lookup | assignment_id }
assignment_targets = !{ assignment_target ~ ("," ~ assignment_target)+ }

expression = _{
  ( return_expression
  | ref_expression
  | function
  | if_statement
  | for_loop
  | while_loop
  | break_keyword
  | continue_keyword
  | operation
  | call
  | debug
  )
  ~ comment?
}
expressions = !{ expression ~ ("," ~ expression?)* }
return_expression = !{ return_keyword ~ expressions }
ref_expression = !{ !ref_id ~ ref_keyword ~ expression }
copy_expression = !{ !copy_id ~ copy_keyword ~ expression }

operation = ${
   (term ~ operation_link+)
   | (term ~ operation_link?)
    ~ (WHITESPACE* ~ comment)?
}
operations = !{ operation ~ (comma_separator ~ operation)* }
operation_link = _{
  (NEWLINE* ~ WHITESPACE+ | empty_line* ~ WHITESPACE+)*
  ~ op ~ WHITESPACE* ~ term
}

op = _{
  add | subtract
  | multiply | divide | modulo
  | equal | not_equal
  | greater_or_equal | less_or_equal | greater | less
  | and | or
}

add = { "+" }
subtract = { "-" }
multiply = { "*" }
divide = { "/" }
modulo = { "%" }
equal = { "==" }
not_equal = { "!=" }
greater = { ">" }
greater_or_equal = { ">=" }
less = { "<" }
less_or_equal = { "<=" }
and = { "and" }
or = { "or" }

term = _{
  map
  | function_inline
  | flow_term
  | value_term
}

flow_term = _{
  if_inline
  | for_inline
}

value_term = _{(
  empty
  | range
  | call
  | negate
  | map_inline
  | list
  | string
  | number
  | boolean
  | lookup
  | id
  | copy_expression
  | copy_id
  | ref_expression
  | ref_id
  | vec4
  | ("(" ~ operation ~ ")")
  )
  ~ comment?
}
value_terms = !{
  value_term ~ ("," ~ value_term)*
}

if_statement = _{ if_block | if_inline }
if_block = !{
  if_keyword ~ expression ~ child_block
  ~ else_if_block?
  ~ else_block?
}
else_if_block = { NEWLINE* ~ else_if_keyword ~ expression ~ child_block }
else_block = { NEWLINE* ~ "else" ~ child_block }
if_inline = !{
  if_keyword ~ expression
  ~ then_keyword ~ expressions
  ~ (else_keyword ~ expressions)?
}

for_loop = _{ for_block | for_inline }
for_block = !{
  for_keyword ~ for_ids
  ~ in_keyword ~ value_terms
  ~ (if_keyword ~ operation)?
  ~ child_block
}
for_inline = !{
  value_terms
  ~ for_keyword ~ for_ids
  ~ in_keyword ~ value_terms
  ~ (if_keyword ~ operation)?
}
for_id = !{ id | placeholder }
for_ids = { for_id ~ ("," ~ for_id)* }
placeholder = { "_" }

while_loop = !{
  (while_keyword | until_keyword) ~ operation
  ~ child_block
}

call = _{ call_no_parens }
call_no_parens = ${ lookup_or_id ~ WHITESPACE+ ~ operations }

call_args = !{
  "("
  ~ separator_line?
  ~ (operation ~ (comma_separator ~ operation)* ~ comma_separator?)?
  ~ separator_line?
  ~ ")"
}

debug = _{ debug_with_parens | debug_no_parens }
debug_with_parens = ${ debug_keyword ~ call_args }
debug_no_parens = ${ debug_keyword ~ WHITESPACE+ ~ operations }

function = _{ function_block | function_inline }
function_block = !{ function_args ~ child_block }
function_inline = !{ function_args ~ assignment_or_expression }
function_args = {
  "|"
  ~ separator_line*
  ~ (id ~ (comma_separator ~ id)* ~ comma_separator?)?
  ~ separator_line?
  ~ "|"
}

map_inline = !{
  "{"
  ~ separator_line*
  ~ (map_entry_inline ~ (comma_separator ~ map_entry_inline)* ~ comma_separator?)?
  ~ "}"
}
map_entry_inline = !{ id ~ ":" ~ separator_line* ~ operation }

map = @{
  empty_line*
  ~ push_indentation
  ~ map_entries
  ~ DROP
}
map_value = !{ map_entries }
map_entries = @{
  empty_line*
  ~ map_entry
  ~ (next_map_entry)*
}
map_entry = _{ map_entry_block | map_entry_inline }
map_entry_block = !{ id ~ ":" ~ map }
next_map_entry = @{ NEWLINE ~ empty_line* ~ indentation ~ map_entry }

list = !{
  "["
  ~ separator_line*
  ~ (operation ~ (comma_separator ~ operation)* ~ comma_separator?)?
  ~ "]"
}

range = ${ range_arg? ~ range_op ~ range_arg? }
range_op = { ("..=" | "..") }
range_arg = _{ number | call | lookup | id | ("(" ~ operation ~ ")") }

vec4 = _{ vec4_with_parens | vec4_no_parens }
vec4_with_parens = !{
  vec4_keyword
  ~ "("
  ~ separator_line*
  ~ operation ~ (comma_separator ~ operation){, 3} ~ comma_separator?
  ~ ")"
  }
vec4_no_parens = !{ vec4_keyword ~ operation ~ (comma_separator ~ operation){, 3} }

boolean = { "true" | "false" }
negate = { not_keyword ~ operation }

empty = { "()" }

number = @{
  "-"?
  ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
  ~ ("." ~ ASCII_DIGIT+)?
  ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

string = ${ "\"" ~ inner ~ "\"" }
inner = @{ char* }
char = {
  !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
}

assignment_id = !{ global_keyword? ~ id }
copy_id = !{ copy_keyword ~ lookup_or_id }
ref_id = !{ ref_keyword ~ lookup_or_id }
lookup_or_id = _{ lookup | id }
id = @{ single_id }
single_id = @{ !(keyword ~ !id_end) ~ id_start ~ id_end* }
id_start = @{ ASCII_ALPHA }
id_end = @{ ASCII_ALPHANUMERIC | "_" }

lookup = ${ (id | "(" ~ operation ~ ")") ~ lookup_node+ }
lookup_node = _{ index | call_args | map_access }
index = ${ "[" ~ operation ~ "]" }
map_access = ${ ("." ~ id) }

keyword = _{
  "and"
  | "break"
  | "continue"
  | "copy"
  | "debug"
  | "else"
  | "false"
  | "for"
  | "global"
  | "if"
  | "in"
  | "not"
  | "or"
  | "ref"
  | "return"
  | "then"
  | "true"
  | "until"
  | "vec4"
  | "while"
}

break_keyword = @{ "break" }
continue_keyword = @{ "continue"  }
copy_keyword = @{ "copy" ~ WHITESPACE+ }
debug_keyword = @{ "debug" }
else_if_keyword = @{ "else if" ~ WHITESPACE+ }
else_keyword = @{ "else" ~ WHITESPACE+ }
for_keyword = @{ "for" ~ WHITESPACE+ }
global_keyword = @{ "global" ~ WHITESPACE+ }
if_keyword = @{ "if" ~ WHITESPACE+ }
in_keyword = @{ "in" ~ WHITESPACE+ }
not_keyword = @{ "not" ~ WHITESPACE+ }
ref_keyword = @{ "ref" ~ WHITESPACE+ }
return_keyword = @{ "return" ~ WHITESPACE+ }
then_keyword = @{ "then" ~ WHITESPACE+ }
until_keyword = @{ "until" ~ WHITESPACE+ }
vec4_keyword = @{ "vec4" }
while_keyword = @{ "while" ~ WHITESPACE+ }

comma_separator = _{ "," ~ separator_line* }
separator_line = _{ inline_comment? ~ NEWLINE ~ (comment ~ NEWLINE)* }

WHITESPACE = _{ whitespace_char | ("\\" ~ whitespace_char* ~ NEWLINE) }
whitespace_char = _{ " " | "\t" }
empty_line = @{ NEWLINE | (WHITESPACE+ ~ NEWLINE) | (WHITESPACE* ~ comment) }
comment = _{ multiline_comment | inline_comment }
inline_comment = _{ "#" ~ (!NEWLINE ~ ANY)* }
multiline_comment = _{ "#-" ~ (!"-#" ~ multiline_comment* ~ ANY)* ~ "-#" }
