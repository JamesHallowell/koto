program = @{
  SOI
  ~ (block ~ (empty_line+ ~ block)*)?
  ~ empty_line*
  ~ EOI
}

block = @{
  empty_line*
  ~ expressions ~ (next_expressions)*
}
child_block = @{
  empty_line*
  ~ push_indentation
  ~ (map_value | block)
  ~ DROP
}

expression_block = @{
  empty_line*
  ~ push_indentation
  ~ expressions
  ~ (WHITESPACE* ~ ",")?
  ~ next_expressions*
  ~ DROP
}
next_expressions = @{
  NEWLINE
  ~ empty_line*
  ~ indentation
  ~ expressions
  ~ (WHITESPACE* ~ ",")?
}

push_indentation = @{ indentation ~ PUSH(indent) }
indentation = @{ PEEK_ALL }
indent = _{ WHITESPACE+ }

expressions = !{ expression ~ ("," ~ expression?)* }
expression = _{
  ( assignment
  | return_expression
  | copy_expression
  | copy_id
  | function
  | if_statement
  | for_loop
  | while_block
  | break_
  | continue_
  | flow_inline
  | operation
  | debug_expression
  )
  ~ comment?
}
return_expression = !{ return_keyword ~ expressions | return_ }
copy_expression = !{ !copy_id ~ copy_keyword ~ expression }

flow_inline = _{
  for_inline
  | while_inline
}

assignment = _{ single_assignment | multiple_assignment }
single_assignment = !{
  assignment_target
  ~ assignment_operator
  ~ (expressions | expression_block)
}
multiple_assignment = !{
  assignment_targets
  ~ "=" ~ (expressions | expression_block) }
assignment_target = _{ lookup | assignment_id }
assignment_targets = !{ assignment_target ~ ("," ~ assignment_target)+ }

assignment_operator = _{
  assign
  | assign_add
  | assign_subtract
  | assign_multiply
  | assign_divide
  | assign_modulo
}

operation = ${
   (term ~ operation_link+)
   | (term ~ operation_link?)
    ~ (WHITESPACE* ~ comment)?
}
operations = !{ operation ~ (comma_separator ~ operation)* }
operation_link = _{
  (NEWLINE* ~ WHITESPACE+ | empty_line* ~ WHITESPACE+)*
  ~ op
  ~ ((WHITESPACE+ ~ call_or_value_term) | (WHITESPACE* ~ map))
}

op = _{
  add | subtract
  | multiply | divide | modulo
  | equal | not_equal
  | greater_or_equal | less_or_equal | greater | less
  | and | or
}

// map is broken out here to allow for block map assignment, e.g.
// m =
//   foo: 0
//   bar: 1
term = _{
  map
  | call_or_value_term
}

// function calls are broken out from value_terms to disambiguate a series of arguments
// from a series of values.
call_or_value_term = _{ function_call | value_term }
call_or_value_terms = _{ function_call | value_terms }

value_term = _{(
  empty
  | range
  | negate
  | map_inline
  | function
  | list
  | string
  | number
  | boolean
  | negatable_lookup
  | id
  | vec4_expression
  | if_inline
  | ("(" ~ expression ~ ")")
  )
  ~ comment?
}
value_terms = !{
  value_term ~ ("," ~ value_term)*
}

if_statement = _{ if_block | if_inline }
if_block = !{
  if_keyword ~ expression ~ child_block
  ~ else_if_block?
  ~ else_block?
}
else_if_block = { NEWLINE* ~ else_if_keyword ~ expression ~ child_block }
else_block = { NEWLINE* ~ else_ ~ child_block }
if_inline = !{
  if_keyword ~ expression
  ~ then_keyword ~ expressions
  ~ (else_keyword ~ expressions)?
}

for_loop = _{ for_block | for_inline }
for_block = !{
  for_keyword ~ for_ids
  ~ in_keyword ~ value_terms
  ~ (if_keyword ~ operation)?
  ~ child_block
}
for_inline = !{
  call_or_value_terms
  ~ for_keyword ~ for_ids
  ~ in_keyword ~ expressions
  ~ (if_keyword ~ expression)?
}
for_id = !{ id | placeholder }
for_ids = { for_id ~ ("," ~ for_id)* }
placeholder = ${ "_" ~ WHITESPACE+ }

while_block = !{
  (while_keyword | until_keyword) ~ operation
  ~ child_block
}

while_inline = !{
  call_or_value_terms
  ~ (while_keyword | until_keyword) ~ operation
}

function_call = _{ call_no_parens }
call_no_parens = ${
  lookup_or_id
  ~ ((WHITESPACE+ ~ value_term+){2, } | (WHITESPACE+ ~ operation))
  ~ !(WHITESPACE* ~ ":")
  }

call_args = !{
  "("
  ~ separator_line*
  ~ (value_term ~ separator_line*)*
  ~ ")"
}

debug_expression = _{ debug_with_parens | debug_no_parens }
debug_with_parens = ${ debug ~ call_args }
debug_no_parens = !{ debug_keyword ~ expression }

function = _{ function_block | function_inline }
function_block = !{ function_args ~ child_block }
function_inline = !{ function_args ~ expressions }
function_args = {
  "|"
  ~ separator_line*
  ~ (id ~ separator_line*)*
  ~ "|"
}

map_inline = !{
  "{"
  ~ separator_line*
  ~ (map_entry_inline ~ (comma_separator ~ map_entry_inline)* ~ comma_separator?)?
  ~ "}"
}
map_entry_inline = !{ id ~ ":" ~ separator_line* ~ operation }

map = @{
  empty_line*
  ~ push_indentation
  ~ map_entries
  ~ DROP
}
map_value = !{ map_entries }
map_entries = @{
  empty_line*
  ~ map_entry
  ~ (next_map_entry)*
}
map_entry = _{ map_entry_block | map_entry_inline }
map_entry_block = !{ id ~ ":" ~ map }
next_map_entry = @{ NEWLINE ~ empty_line* ~ indentation ~ map_entry }

list = !{
  "["
  ~ separator_line*
  ~ ((flow_inline ~ separator_line*) | (value_term ~ separator_line*)*)
  ~ "]"
}

range = ${ range_arg? ~ range_op ~ range_arg? }
range_op = { ("..=" | "..") }
range_arg = _{ number | function_call | negatable_lookup | id | ("(" ~ expression ~ ")") }

vec4_expression = _{ vec4_with_parens | vec4_no_parens }
vec4_with_parens = !{
  vec4
  ~ "("
  ~ separator_line*
  ~ value_term ~ (separator_line* ~ value_term){, 3} ~ separator_line*
  ~ ")"
  }
vec4_no_parens = ${
  vec4
  ~ WHITESPACE+ ~ value_term
  ~ (WHITESPACE+ ~ value_term){, 3}
}

boolean = { true_ | false_ }
negate = { not_keyword ~ operation }

empty = { "()" }

number = @{
  "-"?
  ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
  ~ ("." ~ ASCII_DIGIT+)?
  ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

string = ${ "\"" ~ inner ~ "\"" }
inner = @{ char* }
char = {
  !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
}

assignment_id = !{ export_keyword? ~ id }
copy_id = !{ copy_keyword ~ lookup_or_id }
lookup_or_id = _{ lookup | id }
id = ${ negative? ~ single_id }
single_id = @{
  !(keyword ~ !id_end)
  ~ id_start
  ~ id_end*
}
id_start = @{ ASCII_ALPHA }
id_end = @{ ASCII_ALPHANUMERIC | "_" }

negatable_lookup = ${ negative? ~ lookup }
lookup = ${ (single_id | "(" ~ operation ~ ")") ~ lookup_node+ }
lookup_node = _{ index | call_args | map_access }
index = ${ "[" ~ operation ~ "]" }
map_access = ${ ("." ~ id) }

add = { "+" }
subtract = { "-" }
multiply = { "*" }
divide = { "/" }
modulo = { "%" }
equal = { "==" }
not_equal = { "!=" }
greater = { ">" }
greater_or_equal = { ">=" }
less = { "<" }
less_or_equal = { "<=" }
and = { "and" }
or = { "or" }
negative = ${ "-" }

assign = { "=" }
assign_add = { "+=" }
assign_subtract = { "-=" }
assign_multiply = { "*=" }
assign_divide = { "/=" }
assign_modulo = { "%=" }

break_ = { "break" }
continue_ = { "continue"  }
copy = { "copy" }
debug = { "debug" }
else_ = { "else" }
false_ = { "false" }
for_ = { "for" }
export = { "export" }
if_ = { "if" }
in_ = { "in" }
not = { "not" }
return_ = { "return" }
then = { "then" }
true_ = { "true" }
until = { "until" }
vec4 = { "vec4" }
while_ = { "while" }

keyword = _{
  and
  | break_
  | continue_
  | copy
  | debug
  | else_
  | false_
  | for_
  | export
  | if_
  | in_
  | not
  | or
  | return_
  | then
  | true_
  | until
  | vec4
  | while_
}

copy_keyword = @{ copy ~ WHITESPACE+ }
debug_keyword = @{ debug ~ WHITESPACE+ }
else_if_keyword = @{ else_ ~ WHITESPACE+ ~ if_ ~ WHITESPACE+ }
else_keyword = @{ else_ ~ WHITESPACE+ }
for_keyword = @{ for_ ~ WHITESPACE+ }
export_keyword = @{ export ~ WHITESPACE+ }
if_keyword = @{ if_ ~ WHITESPACE+ }
in_keyword = @{ in_ ~ WHITESPACE+ }
not_keyword = @{ not ~ WHITESPACE+ }
return_keyword = @{ return_ ~ WHITESPACE+ }
then_keyword = @{ then ~ WHITESPACE+ }
until_keyword = @{ until ~ WHITESPACE+ }
while_keyword = @{ while_ ~ WHITESPACE+ }

comma_separator = _{ ("," ~ separator_line*) | separator_line* }
separator_line = _{ inline_comment? ~ (WHITESPACE+ | NEWLINE) ~ (comment ~ NEWLINE)* }

WHITESPACE = _{ whitespace_char | ("\\" ~ whitespace_char* ~ NEWLINE) }
whitespace_char = _{ " " | "\t" }
empty_line = @{ NEWLINE | (WHITESPACE+ ~ NEWLINE) | (WHITESPACE* ~ comment) }
comment = _{ multiline_comment | inline_comment }
inline_comment = _{ "#" ~ (!NEWLINE ~ ANY)* }
multiline_comment = _{ "#-" ~ (!"-#" ~ multiline_comment* ~ ANY)* ~ "-#" }
