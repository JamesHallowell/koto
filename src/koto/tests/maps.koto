o = { min: 0 max: || 42 }
assert_eq 42 o.max()
o2 = o
assert_eq o o2

sum = 0
for i in o.min..o.max()
  sum = sum + i
assert_eq sum 861

m =
  foo: 42
  # Functions can be initialized as map values
  square: |x| x * x
  # Child maps can be defined inline
  baz:
    child_foo: 99

# Access
assert_eq m.foo 42
assert_eq (m.square 9) 81
assert_eq m.baz.child_foo 99

# Adding values to a map
m2 = m + { baz: 99 }
assert_eq m2.baz 99
assert_eq m2.baz.child_foo.wtf 99 # TODO fixme
m2 += { extra: -1 }
assert_eq m2.extra -1

# Modification of map values
m.foo /= 2
assert_eq m.foo 21
assert_eq m2.foo 42

m.baz.child_foo = -1
assert_eq m.baz.child_foo -1

# map.keys
assert_eq (list.sort_copy (map.keys m)) ["baz" "foo" "square"]
assert_eq (list.sort_copy (map.keys m2)) ["baz" "extra" "foo" "square"]


###### Maps as classes

make_o = ||
  foo: 42
  get_foo: |self| self.foo # self refers to table instance

o = make_o()
assert_eq 42 o.get_foo() # implicit self

make_o2 = ||
  make_o() +
    foo_2: 57
    get_foo_2: |self| self.foo_2
    set_foo_2: |self x| self.foo_2 = x
    sum_foo: |self| self.foo + self.foo_2

o2 = make_o2()
assert_eq o2.foo 42
assert_eq o2.get_foo_2() 57
o2.set_foo_2 58
assert_eq o2.sum_foo() 100


###### Maps captured from for loops and control flow

a = for x, y in 1..=3, 4..=6
  foo: x
  bar: y

assert_eq a [{foo: 1 bar: 4} {foo: 2 bar: 5} {foo: 3 bar: 6}]

make_map = |n|
  if n >= 0
    type: "positive"
    n: n
  else
    type: "negative"
    n: n

p = make_map 100
assert_eq p.type "positive" # TODO (make_map 100).type
n = make_map -100
assert_eq n.type "negative"
