o = { min: 0, max: || 42 }
assert_eq 42, o.max()
o2 = o
assert_eq o, o2

sum = 0
for i in o.min..o.max()
  sum = sum + i
assert_eq sum, 861

m =
  foo: 42
  bar: |x| x * x
  # This comment doesn't interrupt map declaration
  baz:
    foo: 99

# Access
assert_eq m.foo, 42
assert_eq 81, m.bar 9
assert_eq m.baz.foo, 99

# Addition
m2 = m + { baz: 99 }
assert (m2.bar 2) == 4 and m2.baz == 99

assert_eq (list.sort_copy map.keys m), ["bar", "baz", "foo"]


###### Maps as classes

make_o = ||
  foo: 42
  get_foo: |self| 42 # self refers to table instance

o = make_o()
assert_eq 42, o.get_foo() # implicit self

make_o2 = ||
  make_o() +
    foo_2: 57
    get_foo_2: |self| self.foo_2
    set_foo_2: |self, x| self.foo_2 = x
    sum_foo: |self| self.foo + self.foo_2

o2 = make_o2()
assert_eq o2.foo, 42
assert_eq o2.get_foo_2(), 57
o2.set_foo_2(58)
assert_eq o2.sum_foo(), 100


###### Maps captured from for loops and control flow

a = for x, y in 1..=3, 4..=6
  foo: x
  bar: y

assert_eq a, [{foo: 1, bar: 4}, {foo: 2, bar: 5}, {foo: 3, bar: 6}]

make_map = |n|
  if n >=0
    type: "positive"
    n: n
  else
    type: "negative"
    n: n

p = make_map 100
assert_eq p.type, "positive" # TODO (make_map 100).type
n = make_map -100
assert_eq n.type, "negative"


####### Assigning to map entries

x =
  foo: 0
  bar:
    baz: -1
y = x
z = x.bar

assert_eq x.foo, 0
x.foo = "^_^"
assert_eq x.foo, "^_^"
assert_eq x.bar.baz, -1
x.bar.baz = [1, 2, 3]
assert_eq x.bar.baz, [1, 2, 3]

# y and z haven't been modified
debug y.bar.baz
assert_eq y, {foo: 0, bar: {baz: -1}}
assert_eq z, {baz: -1}

# New entries can be added
x.new = "O_o"
assert_eq (list.sort_copy map.keys x), ["bar", "foo", "new"]
x.bar.new = ">_<"
assert_eq (list.sort_copy map.keys x.bar), ["baz", "new"]

# Maps can be nested deeply
deep = {a: {b: {c: {d: {e: {f: 42}}}}}}
assert_eq deep.a.b.c.d.e.f, 42
deep.a.b.c.d.e.f = 99
assert_eq deep.a.b.c.d.e.f, 99


