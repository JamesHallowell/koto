o = { min: 0, max: || 42 }
assert_eq 42, o.max()
o2 = o
assert_eq o, o2

sum = 0
for i in o.min..o.max()
  sum = sum + i
assert_eq sum, 861

m =
  foo: 42
  bar: |x| x * x
  # This comment doesn't interrupt map declaration
  baz:
    foo: 99

# Access
assert_eq m.foo, 42
assert_eq 81, m.bar 9
assert_eq m.baz.foo, 99

# Addition
m2 = m + { baz: 99 }
assert (m2.bar 2) == 4 and m2.baz == 99
m2 += { extra: -1 }
assert m2.extra == -1
m2.foo /= 2
assert m2.foo == 21

assert_eq (list.sort_copy map.keys m), ["bar", "baz", "foo"]


###### Maps as classes

make_o = ||
  foo: 42
  get_foo: |self| self.foo # self refers to table instance

o = make_o()
assert_eq 42, o.get_foo() # implicit self

make_o2 = ||
  make_o() +
    foo_2: 57
    get_foo_2: |self| self.foo_2
    set_foo_2: |self x| self.foo_2 = x
    sum_foo: |self| self.foo + self.foo_2

o2 = make_o2()
assert_eq o2.foo, 42
assert_eq o2.get_foo_2(), 57
o2.set_foo_2(58)
assert_eq o2.sum_foo(), 100


###### Maps captured from for loops and control flow

a = for x, y in 1..=3, 4..=6
  foo: x
  bar: y

assert_eq a, [{foo: 1, bar: 4}, {foo: 2, bar: 5}, {foo: 3, bar: 6}]

make_map = |n|
  if n >=0
    type: "positive"
    n: n
  else
    type: "negative"
    n: n

p = make_map 100
assert_eq p.type, "positive" # TODO (make_map 100).type
n = make_map -100
assert_eq n.type, "negative"
