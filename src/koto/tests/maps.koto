import map
from test import assert assert_eq assert_ne

# Maps are a collection of key/value pairs
m = {key: "value", another_key: "another_value"}

# A map's values can be accessed via their keys using '.', known as a 'lookup'
assert_eq m.key "value"
assert_eq m.another_key "another_value"

# Map values can be updated via lookups
m.key = 42
assert_eq m.key 42

# New key/value pairs can be added to the map via lookup
m.new_key = -1
assert_eq m.new_key -1

# Quoted strings can be used for keys that would otherwise be disallowed
x = {"for": -1, "while": 99, "20": "twenty"}
assert_eq x."for" -1
assert_eq x."while" 99
assert_eq x."20" "twenty"

# Unicode can be used in map keys
x.ƒöó = 123
assert_eq x.ƒöó 123

# 'in' can be used to check if a key is in a map
assert "ƒöó" in x

# Any Koto value can be placed in a map, for example, functions
o = {min: 0, max: || 42}
assert_eq 42 o.max()

sum = 0
for i in o.min..o.max()
  sum += i
assert_eq sum 861

# Maps can be assigned to new identifiers
o2 = o
# Maps can be compared for equality
assert_eq o o2

# Maps share their data by default, but you can make a separate copy of the data if needed
o2.min = -1
assert_eq o o2 # o and o2 share the same data
o3 = copy o
o3.min = 99
assert_ne o o3 # o and o3 have separate data

# Maps can be defined using nested blocks
m =
  foo: 42
  # Functions can be initialized as map values
  square: |x| x * x
  # Child maps can be defined inline
  baz:
    child_foo: 99

# Access
assert_eq m.foo 42
assert_eq (m.square 9) 81
assert_eq m.baz.child_foo 99

# Adding values to a map
m2 = m + { baz: 99 }
assert_eq m2.baz 99
m2 += { extra: -1 }
assert_eq m2.extra -1

# Modification of map values
m.foo /= 2
assert_eq m.foo 21
assert_eq m2.foo 42

m.baz.child_foo = -1
assert_eq m.baz.child_foo -1

# size returns number of map entries
assert_eq (size m) 3
assert_eq (size m2) 4

# map.keys
assert_eq (map.keys m) ["foo" "square" "baz"]
assert_eq (map.keys m2) ["foo" "square" "baz" "extra"]


###### Maps as classes

make_o = ||
  foo: 42
  get_foo: |self| self.foo # self refers to table instance

o = make_o()
assert_eq 42 o.get_foo() # implicit self

make_o2 = ||
  make_o() +
    foo_2: 57
    get_foo_2: |self| self.foo_2
    set_foo_2: |self x| self.foo_2 = x
    sum_foo: |self| self.foo + self.foo_2

o2 = make_o2()
assert_eq o2.foo 42
assert_eq o2.get_foo_2() 57
o2.set_foo_2 58
assert_eq o2.sum_foo() 100


###### Maps captured from for loops and control flow

a = [{foo: x, bar: y} for x, y in 1..=3, 4..=6]

assert_eq a [{foo: 1, bar: 4} {foo: 2, bar: 5} {foo: 3, bar: 6}]

make_map = |n|
  if n >= 0
    sign: "positive"
    n: n
  else
    sign: "negative"
    n: n

p = make_map 100
assert_eq p.sign "positive" # TODO (make_map 100).type
n = make_map -100
assert_eq n.sign "negative"
