# References allow for values to be shared between bindings
x = 1
y = ref x
y = 42
assert_eq x, 42

# A reference can be created from a literal
a = ref 1
b = a
b = 99
assert_eq a, 99

# ref can be used to turn a value into a reference
t = "hi"
t = ref t
u = t
u = "bye"
assert_eq t, "bye"

# copy can be used to make a copy of a reference's value
x = ref 1
y = copy x
x = 2
assert_eq y, 1

# Assigning a reference to another doesn't modify existing references
x = ref 1
y = x
x = ref 2
assert_eq x, 2
assert_eq y, 1

# Assigning a reference to itself is a no-op
x = x
assert_eq x, 2

# Modifying a list makes a COW clone by default
a = [1, 2, 3]
b = a
assert_eq a, b
a[1] = 42
assert_ne a, b

# ref assignment turns the source and target lists into references to each other
c = ref a
assert_eq a, c

# Modifications to a or c will be reflected in each other
a[0] = 99
assert_eq a, c
c[2] = -1
assert_eq a, c

# Assigning a ref to a new value creates a new reference to the data
d = c
# Using the ref keyword with a reference will bind to the underlying data
e = ref c

assert_eq c, d
assert_eq c[0], 99 # Indexing a reference to a list works as expected
assert_eq d, e
assert_eq e, [99, 42, -1]

# Reassigning a ref with a new type doesn't affect other refs
a = "hi"
assert_eq a, "hi"
assert_eq c, [99, 42, -1]

# Reassigning a ref with the same type will be reflected in the other references
c = [-1, -2, -3]
assert_eq c, e
assert_eq e, [-1, -2, -3]

# b remains untouched
assert_eq b, [1, 2, 3]

# References can be used as function arguments
a = []
fill_n = |data, n, x|
  data = x for _ in 0..n
fill_n ref a, 3, 7
assert_eq a, [7, 7, 7]

# Referenced lists can be used as for loop ranges
b = x for x in a
assert_eq b, [7, 7, 7]

# Maps can be references too
m = {foo: 42}
n = ref m
n.foo = 99
assert_eq m.foo, 99
