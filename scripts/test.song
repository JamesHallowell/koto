# This is a comment
print "Hello, World!" # This is a trailing comment

#-
Multiline comments start with #- and end with -#
#- and -# can be nested
-#


###### Basic types and logic
a = true
print a
assert_eq(a, true)
assert false or false or a

assert (4 + 3) == 7
assert_eq(1 + 2 * 3, 7)
assert_eq(2 * 2 + 3, 7)
assert_eq(2 + 5 % 3, 4)

# Multiple value assignment
a, b = true, false
assert_ne(a, b)
a, b, c = 1, 2, 3
assert (a == 1) and (b == 2) and (c == 3)


###### Functions

# Functions are defined with || argument lists
say_hi = || print "Hi!"
say_hi()

# Arguments belong inside the ||s
# Implicit return of last statement in function
square = |x| x * x

# Muliple-argument functions must be called with parentheses
# Single-argument functions can be called with or without parentheses
print("The square of 7 is ", square 7)

# Multiple arguments are separated by commas
# Multiline functions are indented after the capture list
# Functions can be nested
add = |x, y|
  x2 = x # Nested trailing comment
  do_add = |x, y|
    x = x + y
    x
  result = do_add(x, y)
  assert x == x2 # function arguments are locally scoped
  print(x, " + ", y, " == ", result)
  result
assert_eq(add(1, 2), 3)

# functions can call globally defined functions
add2 = |x, y| add(x, y)
assert_eq(add2(4, -4), 0)

# TODO functions can return multiple values
f = |x| [x - 1, x + 1] # TODO avoid list
a, b = f 0
assert (a == -1) and (b == 1)


####### Lists
z = [10, 10 + 10, 30]
print z

assert_eq(z[1], 20)
assert_eq(z[1 - 1], 10)
y = list.add(z, 40, 50)
assert_eq(y[3], 40)
print y

assert_eq(z, z)
assert_ne(z, [])

assert_eq(z + z, [10, 20, 30, 10, 20, 30])


assert_eq(length z, 3)
assert_eq(length y, 5)

# Lists get unpacked in multiple assignments - TODO unpacking only for 1 arg
a, b, c = [10, 20], [30, 40]
assert (a == 10) and (b == 20) and (c == 30)


###### Ranges
# TODO support from/to ranges

# Ranges are lazily evaluated
r = 0..5
assert_eq(length(r), 5)
print r
# ..= creates an inclusive range
y = 0..=5
assert_eq(length(y), 6)
print y
# Ranges are resolved when inserted in a list
assert_eq(length([10..20]), 10)
assert_eq(length([r]), 5)
# Indexing lists with ranges produces sub-lists
z = |n| n
x = [(z 10)..=(z 20)]
y = x[z(5)..(10 + 0)]
assert_eq(y[0], 15)
assert_eq(length(y), 5)
# Multiple expressions assigned to single value get stored in a list
a = 1, 2
assert_eq(a, [1, 2])


###### Control flow
# TODO else if

# Single line if statement
is_zero = |x| x == 0
if is_zero 0 then print "Zer0"
if is_zero 1 then print "Zer0" else print "Not Zer0"
assert if is_zero 0 then true else false
if true
  # functions in nested local scope can be called recursively
  fib = |n|
    if n < 2 then n else fib(n - 1) + fib(n - 2)
  assert_eq(fib 7, 13)


# Multiline if statement
x = true
if x
  a = 42
  print "In then block"
  assert a == 42

if x == false
  # This comment shouldn't break parsing
  assert false
else
       # ...and neither should this one
  if x == true
      # or this one
    print "Nested in else block"


####### Loops

# For statement blocks
for x in 0..10
  for y in -5..5 if x == y and x < 3
    print(x, " ", y)

# Inline for statement
print("for ", i) for i in 0..3

# List comprehensions
c = [square(x) for x in [1, 2, 3]]
assert_eq(c, [1, 4, 9])

filter = |xs, f| [x for x in xs if f(x)]
a = filter(0..20, |x| x > 15)
assert_eq(a, [16, 17, 18, 19])

# Iterating works over multiple ranges
enumerate = |xs| [[i, x] for i, x in 0..length(xs), xs] # TODO avoid sublist
                                                        # TODO generator
z = [[c, d] for c, d in enumerate 100..103]
assert_eq(z, [[0, 100], [1, 101], [2, 102]])


###### Maps

print { foo: "bar", baz: 99 }
o = { min: 0, max: || 42 }
assert_eq(42, o.max())
o2 = o
assert_eq(o, o2)

sum = 0
for i in o.min..o.max()
  sum = sum + i
assert_eq(sum, 861)

m =
  foo: 42
  bar: |x| square x
  baz:
    foo: 99

assert_eq(m.foo, 42)
assert_eq(m.bar(9), 81)
assert_eq(m.baz.foo, 99)

m2 = m + { baz: 99 }
assert (m2.bar(2) == 4) and (m2.baz == 99)



###### Standard Library

print("sin(1) is ", math.sin 1)

assert list.is_sortable [42, 10, 9]
assert_eq(list.is_sortable ["42", 10, 9], false) # TODO not
assert list.is_sortable ["42", "10", "9"]
assert_eq(list.sort [42, 10, 9], [9, 10, 42])

assert_eq(list.sort map.keys m, ["bar", "baz", "foo"])




###### Maps as classes

# make_o = ||
#   foo: 42
#   print_foo: |self| print self.foo # self refers to table instance

# o = make_o()
# o.print_foo() # implicit self

# make_o2 = ||
#   base: make_o() # base is a convention
#   print_foo2: |self| print self.base.foo # explicit base access
#
# o2 = make_o2()
# o2.print_foo2()



# ###### Classes
# class O
#   new: |self| self.foo = 42
#   with_foo: |x|
#     o = new O
#     o.foo = x
#     o
#   print_foo: |self| print self.foo

# o = new O
# o.print_foo()

# class O2 extends O
#   print_foo2: |self| print super.foo

# o = new O2
# o.print_foo()

