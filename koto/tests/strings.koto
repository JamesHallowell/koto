import string
from test import assert assert_eq assert_ne

export tests =
  test_comparisons: ||
    assert_eq "Hello" "Hello"
    assert_ne "Hello" "Héllö"
    assert_eq ("Hello" + ", " + "World!") "Hello, World!"

  test_addition: ||
    x = "^"
    x += "_" + "^"
    assert_eq x "^_^"

  test_contains: ||
    assert "O_o".contains("_")
    assert not "O_o".contains("@")

  test_is_empty: ||
    assert "".is_empty()
    assert not "abc".is_empty()

  test_slice: ||
    assert_eq ("abcdef".slice 2 5) "cde"
    x = "abcdef".slice 2 # end index is optional
    assert_eq x "cdef"
    assert_eq (x.slice 1 3) "de"
    assert_eq (x.slice 10 13) ()

  test_split: ||
    assert_eq ["a" "b" "c"] ("a,b,c".split ",")
    assert_eq ["" "x" ""] ("oxo".split "o")

  test_to_number: ||
    assert_eq 42.0 (string.to_number "42")
    assert_eq -1.5 "-1.5".to_number()

  test_trim: ||
    assert_eq "x" (string.trim "   x    ")
    assert_eq "foo" "foo    ".trim()
    assert_eq "bar" "     bar".trim()

  test_format: ||
    hello = "Hello"
    world = "World"

    # A string literal is expected as first argument
    assert_eq "Hello, World!" (string.format "Hello, World!")

    # {} is a placeholder for an argument to be included in the string
    assert_eq "Hello, World!" ("{}, {}!".format hello world)

    # Curly braces can be included in the output by escaping them with another curly brace
    assert_eq "{Hello}, World!" ("{{{}}}, {}!".format hello world)

    # Positional placeholders can be used to reference arguments by index
    assert_eq "Hello World, Hello World!" ("{0} {1}, {0} {1}!".format hello world)

    # Identifier placeholders are looked up in a map argument
    assert_eq "O_o" ("{first}_{second}".format {first: "O", second: "o"})
