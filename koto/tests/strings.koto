@tests =
  @test comparisons: ||
    assert_eq "Hello", "Hello"
    assert_ne "Hello", "HÃ©llÃ¶"
    assert_eq ("Hello" + ", " + "World!"), "Hello, World!"
    assert "Hello" < "Hiyaa" and "World" <= "World!"
    assert "Hiyaa" > "Hello" and "World!" >= "World"

  @test single_quotes: ||
    # Strings can use either double or single quotes.
    assert_eq "Hello", 'Hello'

  @test interpolation: ||
    # Identifiers prefixed with $ are formatted into the string.
    hello = "Hello"
    world = "World"
    assert_eq "$hello, $world!", "Hello, World!"

    x = 99
    assert_eq "$x$x-$x$x", "9999-9999"

    # Expressions can be formatted into the string with ${...} syntax.
    assert_eq "x times 10 is ${x * 10}", "x times 10 is 990"

  @test addition: ||
    x = "^"
    x += "_" + "^"
    assert_eq x, "^_^"

  @test indexing: ||
    assert_eq "HÃ©llÃ¶"[4], "Ã¶"
    x = "TschÃ¼ss"
    assert_eq x[0..3], "Tsc"
    assert_eq x[2..=4], "chÃ¼"
    assert_eq x[4..7], "Ã¼ss"
    assert_eq x[..=3], "Tsch"
    assert_eq x[5..], "ss"
    assert_eq "ğŸ‘‹ğŸ¥³ğŸ˜†"[1], "ğŸ¥³"

  @test escape_codes: ||
    # Ascii characters
    assert_eq '\x4f\x5f\x6f', 'O_o'
    # Unicode characters
    assert_eq '\u{1f98b}', 'ğŸ¦‹'

  @test escaped_newlines: ||
    x = "foo \
         bar \
         baz"
    assert_eq x, "foo bar baz"

  @test bytes: ||
    assert_eq "HÃ«y".bytes().to_tuple(), (72, 195, 171, 121)

  @test chars: ||
    hello = "HÃ©llÃ¶"
    assert_eq
      hello.chars().to_tuple(),
      ("H", "Ã©", "l", "l", "Ã¶")

    # chars() is the default iterator for strings
    hello_chars = []
    for c in hello
      hello_chars.push c
    assert_eq hello_chars, hello.to_list()
    assert_eq hello_chars.size(), 5

  @test contains: ||
    assert "O_o".contains("_")
    assert not "O_o".contains("@")

  @test ends_with: ||
    assert "a,b,c".ends_with("")
    assert "a,b,c".ends_with(",c")
    assert not "a,b,c".ends_with(",b")

  @test escape: ||
    x = "
"
    if os.name() == "windows"
      assert_eq x.escape(), "\\r\\n"
    else
      assert_eq x.escape(), "\\n"

    assert_eq "ğŸ‘‹".escape(), "\\u{1f44b}"

  @test from_bytes: ||
    assert_eq (string.from_bytes (72, 195, 171, 121)), "HÃ«y"

  @test is_empty: ||
    assert "".is_empty()
    assert not "abc".is_empty()

  @test lines: ||
    x = "aaa
bbb
ccc"
    assert_eq x.lines().to_tuple(), ("aaa", "bbb", "ccc")

    x2 = "
xxx
yyy
zzz

"
    assert_eq x2.lines().to_tuple(), ("", "xxx", "yyy", "zzz", "")

    x3 = "foo\nbar\nbaz"
    assert_eq x3.lines().to_tuple(), ("foo", "bar", "baz")

  @test replace: ||
    assert_eq ''.replace('foo', 'bar'), ''
    assert_eq ' '.replace(' ', ''), ''
    assert_eq 'hÃ«llÃ¸'.replace('Ã«', 'Ã©Ã©'), 'hÃ©Ã©llÃ¸'

  @test size: ||
    # size returns the number of unicode graphemes in the string,
    # rather than the number of bytes
    assert_eq "".size(), 0
    assert_eq "Ã¸".size(), 1
    assert_eq "abcdef".size(), 6
    assert_eq "Ã¤bcdÃ©f".size(), 6

  @test slice: ||
    assert_eq ("abcdef".slice 2, 5), "cde"
    x = "abcdef".slice 2 # end index is optional
    assert_eq x, "cdef"
    assert_eq (x.slice 1, 3), "de"
    assert_eq (x.slice 10, 13), null

  @test split: ||
    assert_eq "a,b,c".split(",").to_tuple(), ("a", "b", "c")
    assert_eq "O_O".split("O").to_tuple(), ("", "_", "")
    assert_eq "a - b - c".split(" - ").to_tuple(), ("a", "b", "c")

    # split can also take a function that returns true when a character matches
    assert_eq
      "a-b_c-d".split(|c| c == "-" or c == "_").to_tuple(),
      ("a", "b", "c", "d")

  @test starts_with: ||
    assert "a,b,c".starts_with("")
    assert "a,b,c".starts_with("a,")
    assert not "a,b,c".starts_with(",b")

  @test to_lowercase: ||
    assert_eq (string.to_lowercase "ABC 123"), "abc 123"
    assert_eq (string.to_lowercase "HÃ‰LLÃ–"), "hÃ©llÃ¶"

  @test to_number: ||
    x = string.to_number "42"
    assert_eq x, 42
    assert_eq type(x), "Int"

    x = string.to_number "-1.5"
    assert_eq x, -1.5
    assert_eq type(x), "Float"

  @test to_uppercase: ||
    assert_eq (string.to_uppercase "xyz 890"), "XYZ 890"
    assert_eq (string.to_uppercase "GÃ¶rlitzer StraÃŸe"), "GÃ–RLITZER STRASSE"

  @test trim: ||
    assert_eq (string.trim "   x    "), "x"
    assert_eq "foo    ".trim(), "foo"
    assert_eq "     bar".trim(), "bar"
    assert_eq "     ".trim(), ""
